<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>The State of State Management</title>

    <meta
      name="description"
      content="A comparison of state management libraries in 2021"
    />
    <meta name="author" content="Volkan Unsal" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" id="theme" />

    <!-- Theme used for syntax highlighting of code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/monokai.css"
      id="highlight-theme"
    />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h3>The State of State Management (2020)</h3>
          <p>Volkan Unsal</p>

          <aside class="notes">
            Hi everyone. I'm Volkan, a front end engineer on the Agent
            Experience team. Today I'll be talking about state management
            frameworks.
          </aside>
        </section>

        <section>
          <h2>Outline</h2>
          <ul>
            <li>State manager: a definition</li>
            <li>Frameworks</li>
            <li>Evaluation Criteria</li>
            <li>Design Problems (and how to solve them)</li>
            <li>Analysis of frameworks</li>
          </ul>

          <aside class="notes">
            First, we're going to define the term state management framework.
            And differentiate it from a UI framework. Next, we're going to list
            the frameworks that we're going to be analyzing, and talk about why
            they were chosen. Then, we'll look at some evaluation criteria to
            guide our decision. And examine some of the design problems that
            these frameworks try to solve. Finally, we're going to take a close
            look at a small project using each of these frameworks to better
            understand the design choices they have made and their tradeoffs.
          </aside>
        </section>

        <section>
          <h2>State Manager</h2>
          <p>
            A <b>reactive</b> library for changing the global data store that
            drives your app.
          </p>

          <aside class="notes">
            <p>State manager is...</p>
            <p>
              Reactive is another way of saying it emits an event when it
              changes. These events are used by the UI framework to determine
              whether to render the component in the browser. Second thing to
              note here is the word global, as opposed to state local to a
              component. Most UI frameworks provide local state management, and
              some even provide global state management, and we're going to talk
              about some of those next.
            </p>
          </aside>
        </section>

        <section>
          <h2>Frameworks</h2>
          <ul>
            <li>Flux</li>
            <li>Redux</li>
            <li>Zustand</li>
            <li>Valtio</li>
          </ul>

          <aside class="notes">
            <p>
              There are hundreds of frameworks, but I'm going to be analyzing
              only 4 today. They made the cut because they're popular or have
              some feature that make them stand out.
            </p>
            <p>
              Everyone here probably knows or have used Flux and Redux. Flux
              started as a separate state management framework back in 2015 but
              was integrated into React over the years. Redux built on Flux
              architecture and is probably the most popular and well known
              framework today.
            </p>
            <p>
              Others, like Zustand and Valtio, are newcomers, but they have some
              features that make them viable alternatives.
            </p>
          </aside>
        </section>

        <section>
          <section>
            <h2>Evaluation Criteria</h2>
            <ul>
              <li>Simplest API</li>
              <li>Superior Performance</li>
              <li>UI framework agnostic</li>
            </ul>

            <aside class="notes">
              <p>
                Before we start getting deep into it, we need to have an
                evaluation criteria. My personal criteria includes these 3
                principles...
              </p>
            </aside>
          </section>

          <section>
            <h2>Simplest API</h2>
            <ul>
              <li>create store</li>
              <li>subscribe to change events</li>
              <li>mutate state</li>
              <li>read current state</li>
            </ul>

            <aside class="notes">
              <p>
                Taking these principles one by one... let's expand on the first
                one. Simplest API includes these 4 elements.
              </p>
            </aside>
          </section>

          <section data-auto-animate>
            <pre><code class="language-jsx" data-trim data-line-numbers="1|2|6|3">
              const state = create({ count: 0 })
              subscribe(state.count, () => {
                document.querySelector('#counter').value = state.count;
              })
              <div id='counter'>0</div>
              <button onclick='() => { state.count += 1; }'>increment</button>
            </code></pre>
          </section>

          <section>
            <h2>Performance</h2>
            <ul>
              <li>No over-rendering</li>
              <li>No under-rendering</li>
            </ul>

            <aside class="notes">
              <p>
                Over-rendering happens when the state manager does not send
                notifications strategically. We'll see examples of that and why
                this is a problem in a bit.
              </p>
              <p>
                Under rendering can happen in some frameworks that use immutable
                data stores. When you mutate an object in place, rather than
                creating a new object, this can cause under-rendering.
              </p>
            </aside>
          </section>

          <section>
            <h2>Agnostic</h2>
            <p>Usable outside of popular UI frameworks.</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Design Problems</h2>
            <ol>
              <li class="fragment">How to determine what changed?</li>
              <li class="fragment">When to emit change events?</li>
              <li class="fragment">How to communicate changes?</li>
              <li class="fragment">How to mutate state?</li>
            </ol>

            <aside class="notes">
              All state management library authors have to answer these
              questions.
              <ol>
                <li>
                  What changed?
                  <ul>
                    <li>Shallow object comparison</li>
                    <li>Field level comparison</li>
                  </ul>
                </li>
                <li>
                  When to emit?
                  <ul>
                    <li>Immediately</li>
                    <li>At the end of the event loop (batched)</li>
                  </ul>
                </li>
                <li>
                  How to communicate?
                  <ul>
                    <li>Re-render the entire component tree</li>
                    <li>
                      Render only the components that subscribe to the changing
                      field
                    </li>
                  </ul>
                </li>
                <li>
                  How to mutate
                  <ul>
                    <li>Directly</li>
                    <li>Indirectly</li>
                  </ul>
                </li>
              </ol>
            </aside>
          </section>

          <section>
            <h4>Design Choices: Shallow object comparison</h4>
            <small>Redux</small>

            <pre><code class="language-jsx" data-trim>
              // combineReducers.ts
              hasChanged = nextStateForKey !== previousStateForKey
              return hasChanged ? nextState : state
            </code></pre>

            <aside class="notes">
              We check the object identity of the store to decide whether the
              data store has changed. The stored object must be immutable to
              make this possible. We also don't know which field did change at
              this point. We only know that a change has occurred.
            </aside>
          </section>

          <section>
            <h4>Design Choices: Field level comparison</h4>
            <small>Valtio</small>
            <pre><code class="language-jsx" data-trim>
              set(target, prop, value) {
                const prevValue = target[prop]
                if (Object.is(prevValue, value)) return true
                target[prop] = value
                notifyUpdate()
              }
            </code></pre>

            <aside class="notes">
              Valtio is a proxy based state management framework. It works by
              wrapping the data store with a Javascript Proxy object. As you can
              see here, the setter on the Proxy is aware of the target, prop
              name, and next value of the prop. This comparison happens at the
              field level, not at state level, so it's much more granular. As
              you will see, this granularity makes some really interesting
              features possible.
            </aside>
          </section>

          <section>
            <h4>Design Choices: Indirect Manipulation</h4>
            <small>Redux</small>
            <pre>
              <code class="language-jsx" data-trim data-line-numbers="11|1-10|12">
                const reducer = (state, action) => { 
                  switch(action.type) {
                    case 'INC':
                      state = { count: state.count + 1 } 
                      break;
                    default:
                      break;
                  }
                  return state;
                };
                const store = createStore(reducer, { count: 0 });
                store.dispatch({ type: 'INC' })
              </code>
            </pre>
            <aside class="notes">
              Indirect manipulation is a design choice that's adopted by state
              management frameworks that require an immutable data store, such
              as Flux and Redux. It basically creates an abstraction layer over
              the stored data, and you can only manipulate your data using a
              reducer and a message sent through a dispatcher.
            </aside>
          </section>

          <section>
            <h4>Design Choices: Indirect Manipulation</h4>
            <small>Zustand</small>
            <pre><code class="language-jsx" data-trim data-line-numbers="3|4|7|">
              const store = create((set, get) => {
                return ({ 
                  count: 0, 
                  inc: () => set({ count: get().count + 1 })
                }) 
              });
              store.inc()
              </code></pre>
          </section>

          <section>
            <h4>Design Choices: Direct Manipulation</h4>
            <small>Valtio</small>
            <pre><code class="language-jsx" data-trim>
              const store = proxy({ count: 0 });
              store.count += 1;
              </code></pre>
          </section>
        </section>
        <section>
          <h2>Framework Analysis</h2>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/search/search.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // Also available as an ES module, see:
      // https://revealjs.com/initialization/
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [
          RevealZoom,
          RevealNotes,
          RevealSearch,
          RevealMarkdown,
          RevealHighlight,
        ],
      });
    </script>
  </body>
</html>
