<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>The State of State Management</title>

    <meta
      name="description"
      content="A comparison of state management libraries in 2021"
    />
    <meta name="author" content="Volkan Unsal" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" id="theme" />

    <!-- Theme used for syntax highlighting of code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/monokai.css"
      id="highlight-theme"
    />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h3>The State of State Management (2020)</h3>
          <p>Volkan Unsal</p>
        </section>

        <section>
          <h2>Overview</h2>
          <ul>
            <li>What is a state manager?</li>
            <li>Frameworks</li>
            <li>Evaluation Criteria</li>
            <li>Design Problems (and how to solve them)</li>
            <li>Comparison of frameworks</li>
          </ul>
        </section>

        <section>
          <h2>State Manager</h2>
          <p>
            A <b>reactive</b> library for changing the global data store that
            drives your app.
          </p>
        </section>

        <section>
          <h2>Frameworks</h2>
          <ul>
            <li>Flux</li>
            <li>Redux</li>
            <li>Zustand</li>
            <li>Valtio</li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Evaluation Criteria</h2>
            <ul>
              <li>Simplest API possible</li>
              <li>Performance</li>
              <li>UI framework agnostic</li>
            </ul>
          </section>

          <section>
            <h2>Simplest API</h2>
            <ul>
              <li>create store</li>
              <li>subscribe to change events</li>
              <li>mutate state</li>
              <li>read current state</li>
            </ul>
          </section>

          <section data-auto-animate>
            <pre><code class="language-jsx" data-trim data-line-numbers="1|4|7|10">
              const state = create({ count: 0 })
  
              const Counter = () => {
                useSubscribe('count')
  
                const onClick = () => {
                  state.count = 1;
                }
  
                return <button onClick={onClick}>{state.count}</button>
              }
            </code></pre>
          </section>

          <section>
            <h2>Performance</h2>
            <ul>
              <li>No over-rendering</li>
              <li>No under-rendering</li>
            </ul>

            <aside class="notes">
              <p>
                Over-rendering happens when the state manager does not send
                notifications strategically. We'll see examples of that and why
                this is a problem in a bit.
              </p>
              <p>
                Under rendering can happen in some frameworks that use immutable
                data stores. When you mutate an object in place, rather than
                creating a new object, this can cause under-rendering.
              </p>
            </aside>
          </section>

          <section>
            <h2>Agnostic</h2>
            <p>Usable outside of popular UI frameworks.</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Design Problems</h2>
            <ol>
              <li class="fragment">How to determine what changed?</li>
              <li class="fragment">When to emit change events?</li>
              <li class="fragment">How to communicate changes?</li>
              <li class="fragment">How to mutate state?</li>
            </ol>

            <aside class="notes">
              All state management library authors have to answer these
              questions.
              <ol>
                <li>
                  What changed?
                  <ul>
                    <li>Shallow object comparison</li>
                    <li>Field level comparison</li>
                  </ul>
                </li>
                <li>
                  When to emit?
                  <ul>
                    <li>Immediately</li>
                    <li>At the end of the event loop (batched)</li>
                  </ul>
                </li>
                <li>
                  How to communicate?
                  <ul>
                    <li>Re-render the entire component tree</li>
                    <li>
                      Render only the components that subscribe to the changing
                      field
                    </li>
                  </ul>
                </li>
                <li>
                  How to mutate
                  <ul>
                    <li>Directly</li>
                    <li>Indirectly</li>
                  </ul>
                </li>
              </ol>
            </aside>
          </section>

          <section>
            <h4>Design Choices: Shallow object comparison</h4>
            <small>Redux</small>

            <pre><code class="language-jsx" data-trim>
              // combineReducers.ts
              hasChanged = nextStateForKey !== previousStateForKey
              return hasChanged ? nextState : state
            </code></pre>

            <aside class="notes">
              We check the object identity of the store to decide whether the
              data store has changed. The stored object must be immutable to
              make this possible. We also don't know which field did change at
              this point. We only know that a change has occurred.
            </aside>
          </section>

          <section>
            <h4>Design Choices: Field level comparison</h4>
            <small>Valtio</small>
            <pre><code class="language-jsx" data-trim>
              set(target, prop, value) {
                const prevValue = target[prop]
                if (Object.is(prevValue, value)) return true
                target[prop] = value
                notifyUpdate()
              }
            </code></pre>

            <aside class="notes">
              Valtio is a proxy based state management framework. It works by
              wrapping the data store with a Javascript Proxy object. As you can
              see here, the setter on the Proxy is aware of the target, prop
              name, and next value of the prop. This comparison happens at the
              field level, not at state level, so it's much more granular. As
              you will see, this granularity makes some really interesting
              features possible.
            </aside>
          </section>

          <section>
            <h4>Design Choices: Indirect Manipulation</h4>
            <small>Redux</small>
            <pre>
              <code class="language-jsx" data-trim data-line-numbers="11|1-10|12">
                const reducer = (state, action) => { 
                  switch(action.type) {
                    case 'INC':
                      state = { count: state.count + 1 } 
                      break;
                    default:
                      break;
                  }
                  return state;
                };
                const store = createStore(reducer, { count: 0 });
                store.dispatch({ type: 'INC' })
              </code>
            </pre>
            <aside class="notes">
              Indirect manipulation is a design choice that's adopted by state
              management frameworks that require an immutable data store, such
              as Flux and Redux. It basically creates an abstraction layer over
              the stored data, and you can only manipulate your data using a
              reducer and a message sent through a dispatcher.
            </aside>
          </section>

          <section>
            <h4>Design Choices: Indirect Manipulation</h4>
            <small>Zustand</small>
            <pre><code class="language-jsx" data-trim data-line-numbers="3|4|7|">
              const store = create((set, get) => {
                return ({ 
                  count: 0, 
                  inc: () => set({ count: get().count + 1 })
                }) 
              });
              store.inc()
              </code></pre>
          </section>

          <section>
            <h4>Design Choices: Direct Manipulation</h4>
            <small>Valtio</small>
            <pre><code class="language-jsx" data-trim>
              const store = proxy({ count: 0 });
              store.count += 1;
              </code></pre>
          </section>
        </section>
        <section>
          <h2>Framework Comparison</h2>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/search/search.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // Also available as an ES module, see:
      // https://revealjs.com/initialization/
      Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [
          RevealZoom,
          RevealNotes,
          RevealSearch,
          RevealMarkdown,
          RevealHighlight,
        ],
      });
    </script>
  </body>
</html>
